<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Vector Field Generator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Load MathJax for LaTeX rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    // Typeset the page when MathJax is ready
                    MathJax.typesetPromise().catch((err) => console.log('MathJax error:', err));
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Style for the explanation modal content */
        #explanation-content p {
            margin-bottom: 1rem;
        }
        #explanation-content ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #06b6d4;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #06b6d4;
            cursor: pointer;
            border: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #374151;
            height: 8px;
            border-radius: 4px;
        }
        input[type="range"]::-moz-range-track {
            background: #374151;
            height: 8px;
            border-radius: 4px;
        }
        /* MathJax inline display fix - prevent extra line breaks */
        mjx-container {
            display: inline !important;
            vertical-align: baseline !important;
            margin: 0 !important;
            padding: 0 !important;
            line-height: 0 !important;
        }
        mjx-container[display="true"] {
            display: block !important;
            text-align: center !important;
            margin: 1em 0 !important;
            line-height: normal !important;
        }
        mjx-container svg {
            display: inline !important;
            vertical-align: baseline !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        /* Force inline in all contexts */
        p mjx-container, li mjx-container, strong mjx-container {
            display: inline !important;
            line-height: inherit !important;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-inter">

    <!-- Main content -->
    <main class="min-h-screen w-full flex flex-col items-center justify-center p-4 md:p-8">
        <div class="text-center mb-6 max-w-5xl w-full">
            <h1 class="text-3xl md:text-5xl font-bold mb-3 text-cyan-400">Gemini Vector Field Generator</h1>
            
            <!-- NEW COLLAPSIBLE DESCRIPTION SECTION -->
            <div class="mb-4 bg-gray-800/30 p-3 rounded-xl text-left shadow-inner">
                <button id="toggle-description" class="w-full flex items-center justify-between text-base font-semibold text-gray-300 hover:text-cyan-400 transition duration-200">
                    What is a 2D Vector Field?
                    <span id="toggle-icon" class="transform transition-transform duration-300 text-lg">‚ñº</span>
                </button>
                <div id="vector-description-content" class="mt-2 text-gray-400 text-sm leading-relaxed hidden border-t border-gray-700 pt-2">
                    <p>A <strong>2D vector field</strong> is a function that assigns a vector (a quantity with both magnitude and direction) to every point in a 2D space. It is mathematically represented as $f(x,y) = P(x,y)\mathbf{i} + Q(x,y)\mathbf{j}$.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>$P(x,y)$ is the expression for the <strong>horizontal movement ($x$-component)</strong>.</li>
                        <li>$Q(x,y)$ is the expression for the <strong>vertical movement ($y$-component)</strong>.</li>
                    </ul>
                    <p class="mt-2">In this visualizer, the particles move along the paths dictated by the vector at their current position. You can use the Gemini generator above to describe your own functions!</p>
                </div>
            </div>
            <!-- END NEW COLLAPSIBLE DESCRIPTION SECTION -->

            <p id="equation-description" class="text-lg md:text-xl text-gray-300 transition-all duration-300">
                Visualizing <code class="bg-gray-800 text-cyan-300 px-2 py-1 rounded">f(x,y) = (sin(x)+sin(y))√Æ + (sin(x)-sin(y))ƒµ</code>
            </p>
        </div>

        <!-- NEW: Gemini Interaction Panel -->
        <div class="w-full max-w-5xl mb-4 p-4 bg-gray-800/50 border border-gray-700 rounded-lg shadow-lg">
            <div class="flex items-start gap-2 mb-2">
                <label for="prompt-input" class="text-sm font-medium text-cyan-400 whitespace-nowrap pt-1">Describe a vector field you want to see:</label>
                <button id="toggle-api-key" class="text-xs text-gray-400 hover:text-cyan-400 transition duration-200 whitespace-nowrap">
                    [API Key ‚ñº]
                </button>
            </div>
            <div id="api-key-container" class="hidden mb-2">
                <input type="text" id="api-key-input" class="w-full p-2 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500 text-sm" placeholder="Enter your Gemini API key (optional - overrides default key)">
            </div>
            <textarea id="prompt-input" rows="2" class="w-full p-2 bg-gray-900 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500" placeholder="e.g., 'a swirling vortex in the middle', 'a flow moving right', 'complex waves'"></textarea>
            
            <div class="flex flex-col sm:flex-row gap-3 mt-3">
                <button id="generate-button" class="flex-1 bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200">
                    Generate New Field ‚ú®
                </button>
                <button id="explain-button" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200">
                    Explain Current Field ‚ú®
                </button>
                <button id="export-button" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-200">
                    Export Animation üìã
                </button>
            </div>
            <p id="api-status" class="text-center text-sm text-gray-400 mt-3 h-5"></p> <!-- Status message area -->

            <!-- NEW: Preset Dropdown -->
            <div class="mt-4 pt-3 border-t border-gray-700">
                <label for="preset-select" class="block text-sm font-medium text-cyan-400 mb-2">Or, try a preset field:</label>
                <select id="preset-select" class="w-full p-2 bg-gray-900 border border-gray-700 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <option value="">-- Select a preset --</option>
                    <option value="vortex">üåÄ Central Vortex</option>
                    <option value="wave">üåä Complex Waves</option>
                    <option value="sink">‚ö´ Central Sink</option>
                    <option value="spiral">üå™Ô∏è Expanding Spiral</option>
                    <option value="turbulence">üí® Turbulence</option>
                    <option value="radial">üí´ Radial Expansion</option>
                </select>
            </div>

            <!-- NEW: Customization Controls -->
            <div class="mt-4 pt-3 border-t border-gray-700">
                <p class="text-sm font-medium text-cyan-400 mb-3">Customization:</p>
                
                <!-- Color Controls -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3 mb-3">
                    <div>
                        <label for="color-start" class="block text-xs text-gray-400 mb-1">Particle Color Start:</label>
                        <input type="color" id="color-start" value="#00ffff" class="w-full h-8 rounded border border-gray-700 cursor-pointer">
                    </div>
                    <div>
                        <label for="color-end" class="block text-xs text-gray-400 mb-1">Particle Color End:</label>
                        <input type="color" id="color-end" value="#0080ff" class="w-full h-8 rounded border border-gray-700 cursor-pointer">
                    </div>
                    <div>
                        <label for="bg-color" class="block text-xs text-gray-400 mb-1">Background Color:</label>
                        <input type="color" id="bg-color" value="#111827" class="w-full h-8 rounded border border-gray-700 cursor-pointer">
                    </div>
                </div>

                <!-- Slider Controls -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <div>
                        <label for="count-slider" class="block text-xs text-gray-400 mb-1">Particle Count: <span id="count-value">1500</span></label>
                        <input type="range" id="count-slider" min="100" max="3000" step="100" value="1500" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="size-slider" class="block text-xs text-gray-400 mb-1">Particle Size: <span id="size-value">1</span>px</label>
                        <input type="range" id="size-slider" min="1" max="5" step="1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="speed-slider" class="block text-xs text-gray-400 mb-1">Particle Speed: <span id="speed-value">1.0</span>x</label>
                        <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- The canvas element where the visualization will be drawn -->
        <div class="w-full max-w-5xl aspect-[4/3] bg-gray-950 rounded-lg shadow-2xl border-2 border-cyan-700/50 overflow-hidden">
            <canvas id="flowCanvas"></canvas>
        </div>
    </main>

    <!-- NEW: Explanation Modal -->
    <div id="explanation-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 hidden">
        <div class="bg-gray-800 w-full max-w-2xl rounded-lg shadow-2xl border border-gray-700 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-2xl font-bold text-cyan-400">Field Explained ‚ú®</h2>
                <button id="close-modal-button" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="explanation-content" class="p-6 text-gray-300 leading-relaxed">
                <!-- Content will be injected by JavaScript -->
                <p>Loading explanation...</p>
            </div>
        </div>
    </div>

    <!-- NEW: Export Modal -->
    <div id="export-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 hidden">
        <div class="bg-gray-800 w-full max-w-4xl rounded-lg shadow-2xl border border-gray-700 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-2xl font-bold text-green-400">Export Animation üìã</h2>
                <button id="close-export-modal-button" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div class="p-6">
                <p class="text-gray-300 mb-4">Copy the code below to integrate this animation into your own project. See <a href="INTEGRATION.md" target="_blank" class="text-cyan-400 hover:text-cyan-300 underline">INTEGRATION.md</a> for detailed instructions.</p>
                
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm font-medium text-green-400">HTML Code:</label>
                        <button id="copy-html-button" class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-3 rounded transition-all duration-200">
                            Copy HTML
                        </button>
                    </div>
                    <pre class="bg-gray-900 p-4 rounded border border-gray-700 overflow-x-auto"><code id="export-html" class="text-xs text-gray-300"></code></pre>
                </div>

                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm font-medium text-green-400">CSS Code:</label>
                        <button id="copy-css-button" class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-3 rounded transition-all duration-200">
                            Copy CSS
                        </button>
                    </div>
                    <pre class="bg-gray-900 p-4 rounded border border-gray-700 overflow-x-auto"><code id="export-css" class="text-xs text-gray-300"></code></pre>
                </div>

                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm font-medium text-green-400">JavaScript Code:</label>
                        <button id="copy-js-button" class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-3 rounded transition-all duration-200">
                            Copy JS
                        </button>
                    </div>
                    <pre class="bg-gray-900 p-4 rounded border border-gray-700 overflow-x-auto"><code id="export-js" class="text-xs text-gray-300"></code></pre>
                </div>

                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm font-medium text-green-400">Complete HTML File:</label>
                        <button id="copy-complete-button" class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-3 rounded transition-all duration-200">
                            Copy Complete
                        </button>
                    </div>
                    <pre class="bg-gray-900 p-4 rounded border border-gray-700 overflow-x-auto"><code id="export-complete" class="text-xs text-gray-300"></code></pre>
                </div>

                <p id="export-status" class="text-center text-sm text-green-400 mt-3"></p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Canvas and Particle Config ---
            const canvas = document.getElementById('flowCanvas');
            const ctx = canvas.getContext('2d');
            let NUM_PARTICLES = 1500;
            let PARTICLE_SPEED = 1;
            const FIELD_SCALE = 8;
            let FADE_OPACITY = 0.05;
            let HUE_START = 180;
            let HUE_END = 240;
            let PARTICLE_SIZE = 1;
            let BG_COLOR_R = 17;
            let BG_COLOR_G = 24;
            let BG_COLOR_B = 39;

            // --- DOM Element Refs ---
            const generateButton = document.getElementById('generate-button');
            const explainButton = document.getElementById('explain-button');
            const exportButton = document.getElementById('export-button');
            const promptInput = document.getElementById('prompt-input');
            const apiStatus = document.getElementById('api-status');
            const equationDescription = document.getElementById('equation-description');
            const explanationModal = document.getElementById('explanation-modal');
            const explanationContent = document.getElementById('explanation-content');
            const closeModalButton = document.getElementById('close-modal-button');
            const exportModal = document.getElementById('export-modal');
            const closeExportModalButton = document.getElementById('close-export-modal-button');
            const exportHtmlCode = document.getElementById('export-html');
            const exportCssCode = document.getElementById('export-css');
            const exportJsCode = document.getElementById('export-js');
            const exportCompleteCode = document.getElementById('export-complete');
            const exportStatus = document.getElementById('export-status');
            const copyHtmlButton = document.getElementById('copy-html-button');
            const copyCssButton = document.getElementById('copy-css-button');
            const copyJsButton = document.getElementById('copy-js-button');
            const copyCompleteButton = document.getElementById('copy-complete-button');
            const presetSelect = document.getElementById('preset-select');
            const colorStartInput = document.getElementById('color-start');
            const colorEndInput = document.getElementById('color-end');
            const bgColorInput = document.getElementById('bg-color');
            const speedSlider = document.getElementById('speed-slider');
            const sizeSlider = document.getElementById('size-slider');
            const countSlider = document.getElementById('count-slider');
            const speedValue = document.getElementById('speed-value');
            const sizeValue = document.getElementById('size-value');
            const countValue = document.getElementById('count-value');
            const toggleApiKeyButton = document.getElementById('toggle-api-key');
            const apiKeyContainer = document.getElementById('api-key-container');
            const apiKeyInput = document.getElementById('api-key-input');

            // NEW Refs for description
            const toggleDescriptionButton = document.getElementById('toggle-description');
            const descriptionContent = document.getElementById('vector-description-content');
            const toggleIcon = document.getElementById('toggle-icon');

            // --- State ---
            let particles = [];
            let canvasWidth = 0;
            let canvasHeight = 0;
            
            // --- Gemini API State ---
            const defaultApiKey = "AIzaSyCSUUMTIw2UQ6atm5goZARO5q44Sj31wt8";
            let vectorFunction;
            let currentVxString = "Math.sin(x) + Math.sin(y)";
            let currentVyString = "Math.sin(x) - Math.sin(y)";
            let currentDescription = "f(x,y) = (sin(x)+sin(y))√Æ + (sin(x)-sin(y))ƒµ";

            // --- Preset Definitions ---
            const PRESENTS = {
                vortex: {
                    // f(x,y) = -(y - 4)√Æ + (x - 4)ƒµ - creates a counter-clockwise rotation centered at (4, 4)
                    vx: `-(y - (${FIELD_SCALE} / 2))`,
                    vy: `(x - (${FIELD_SCALE} / 2))`,
                    desc: `f(x,y) = -(y - 4)√Æ + (x - 4)ƒµ (Central Vortex)`
                },
                wave: {
                    // f(x,y) = 2 sin(y)√Æ + 2 cos(x)ƒµ - creates a complex flow with horizontal and vertical waves
                    vx: `Math.sin(y) * 2`,
                    vy: `Math.cos(x) * 2`,
                    desc: `f(x,y) = 2 sin(y)√Æ + 2 cos(x)ƒµ (Complex Waves)`
                },
                sink: {
                    // f(x,y) = -0.5(x-4)√Æ - 0.5(y-4)ƒµ - creates a flow directly toward the center (4, 4)
                    vx: `-(x - (${FIELD_SCALE} / 2)) * 0.5`,
                    vy: `-(y - (${FIELD_SCALE} / 2)) * 0.5`,
                    desc: `f(x,y) = -0.5(x-4)√Æ - 0.5(y-4)ƒµ (Central Sink/Attractor)`
                },
                spiral: {
                    // f(x,y) = (-y + 4) + 0.3(x - 4)√Æ + (x - 4) + 0.3(y - 4)ƒµ - creates an expanding spiral
                    vx: `-(y - (${FIELD_SCALE} / 2)) + 0.3 * (x - (${FIELD_SCALE} / 2))`,
                    vy: `(x - (${FIELD_SCALE} / 2)) + 0.3 * (y - (${FIELD_SCALE} / 2))`,
                    desc: `f(x,y) = (-(y-4) + 0.3(x-4))√Æ + ((x-4) + 0.3(y-4))ƒµ (Expanding Spiral)`
                },
                turbulence: {
                    // f(x,y) = sin(x + y)√Æ + cos(x - y)ƒµ - creates chaotic turbulent flow
                    vx: `Math.sin(x + y) * 2`,
                    vy: `Math.cos(x - y) * 2`,
                    desc: `f(x,y) = 2sin(x+y)√Æ + 2cos(x-y)ƒµ (Turbulence)`
                },
                radial: {
                    // f(x,y) = (x-4)√Æ + (y-4)ƒµ - creates outward radial flow from center
                    vx: `(x - (${FIELD_SCALE} / 2)) * 0.5`,
                    vy: `(y - (${FIELD_SCALE} / 2)) * 0.5`,
                    desc: `f(x,y) = 0.5(x-4)√Æ + 0.5(y-4)ƒµ (Radial Expansion)`
                }
            };

            /**
             * Updates the master function used for the vector field.
             * Uses `new Function` for safe dynamic code execution.
             */
            function updateVectorFunction(vxString, vyString, description) {
                try {
                    // `with(Math)` provides access to Math.sin, Math.cos, etc.
                    vectorFunction = new Function('x', 'y', 
                        `with(Math) { return { x: (${vxString}), y: (${vyString}) }; }`
                    );
                    
                    // Store current state
                    currentVxString = vxString;
                    currentVyString = vyString;
                    currentDescription = description;

                    // Update UI
                    equationDescription.innerHTML = `Visualizing <code class="bg-gray-800 text-cyan-300 px-2 py-1 rounded">${description}</code>`;
                    
                    return true;
                } catch (e) {
                    console.error("Error compiling new vector function:", e);
                    apiStatus.textContent = `Error: Generated function was invalid. ${e.message}`;
                    return false;
                }
            }

            /**
             * Fetches from the Gemini API with exponential backoff.
             */
            async function fetchGeminiApi(payload, retries = 3, delay = 1000) {
                const apiKey = apiKeyInput.value.trim() || defaultApiKey;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            throw new Error(`API Error: ${response.status} ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            
                            return result.candidates[0].content.parts[0].text;
                        } else {
                            throw new Error("Invalid response structure from API.");
                        }
                    } catch (error) {
                        console.error("API call failed:", error);
                        if (i === retries - 1) {
                            throw error; // Re-throw last error
                        }
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    }
                }
            }

            // --- Gemini Feature Handlers ---

            /**
             * ‚ú® Handles clicking the "Generate New Field" button.
             */
            async function handleGenerateClick() {
                const userPrompt = promptInput.value;
                if (!userPrompt) {
                    apiStatus.textContent = "Please enter a description first.";
                    return;
                }

                apiStatus.textContent = "‚ú® Generating new field...";
                generateButton.disabled = true;

                const systemPrompt = `You are a mathematical function generator. The user wants a 2D vector field.
Return *only* a JSON object with two string fields: "vx" and "vy".
These strings must be valid JavaScript expressions using 'x', 'y', and Math functions (e.g., Math.sin, Math.cos, Math.exp, Math.PI).
The (x, y) coordinates will range from 0 to about 8.
Do not use comments. Do not use markdown.
Example for "a simple swirl": {"vx": "-y + 4", "vy": "x - 4"}`;

                const payload = {
                    contents: [{ parts: [{ text: userPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "vx": { "type": "STRING" },
                                "vy": { "type": "STRING" }
                            },
                            required: ["vx", "vy"]
                        }
                    }
                };
                
                try {
                    const jsonString = await fetchGeminiApi(payload);
                    const result = JSON.parse(jsonString);

                    if (result.vx && result.vy) {
                        // Successfully updated function
                        const success = updateVectorFunction(result.vx, result.vy, `Custom field: "${userPrompt}"`);
                        if (success) {
                            setup(); // Re-initialize the particle simulation
                            apiStatus.textContent = "New field generated!";
                            promptInput.value = "";
                        }
                    } else {
                        throw new Error("API response was missing 'vx' or 'vy'.");
                    }

                } catch (error) {
                    console.error("Generation failed:", error);
                    apiStatus.textContent = `Error: ${error.message}`;
                } finally {
                    generateButton.disabled = false;
                }
            }

            /**
             * ‚ú® Handles clicking the "Explain Current Field" button.
             */
            async function handleExplainClick() {
                explanationModal.classList.remove('hidden');
                explanationContent.innerHTML = "<p>‚ú® Thinking... please wait.</p>";
                
                const systemPrompt = `You are a helpful math tutor. Explain the mathematical properties of the following 2D vector field in simple, easy-to-understand terms.
The field is defined as f(x,y) = (vx)√Æ + (vy)ƒµ.
The user's (x, y) coordinates range from 0 to 8.
Format your answer in simple HTML with <p> and <ul> tags. Do not use markdown.
Use LaTeX notation enclosed in dollar signs $ for mathematical expressions (e.g., $f(x,y)$, $\\mathbf{i}$, $\\mathbf{j}$).`;

                const userQuery = `Explain the field:
vx = ${currentVxString}
vy = ${currentVyString}
(Description: ${currentDescription})
What kind of patterns (swirls, waves, flows) would this create and why?`;

                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] }
                };

                try {
                    const explanationText = await fetchGeminiApi(payload);
                    explanationContent.innerHTML = explanationText;
                    // Render LaTeX with MathJax
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        MathJax.typesetPromise([explanationContent]).catch((err) => console.log('MathJax typeset error:', err));
                    }
                } catch (error) {
                    console.error("Explanation failed:", error);
                    explanationContent.innerHTML = `<p class="text-red-400">Sorry, I couldn't generate an explanation. ${error.message}</p>`;
                }
            }

            // --- Preset Handler ---
            function loadPreset(presetId) {
                const preset = PRESENTS[presetId];
                if (preset) {
                    updateVectorFunction(preset.vx, preset.vy, preset.desc);
                    setup(); // Re-initialize particles
                    apiStatus.textContent = `Preset loaded: ${preset.desc}`;
                }
            }

            // --- Color Helper Functions ---
            /**
             * Converts a hex color to RGB object
             */
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            /**
             * Converts RGB to HSL
             */
            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                return { h: h * 360, s: s * 100, l: l * 100 };
            }

            /**
             * Updates color values from hex inputs
             */
            function updateColors() {
                const startRgb = hexToRgb(colorStartInput.value);
                const endRgb = hexToRgb(colorEndInput.value);
                const bgRgb = hexToRgb(bgColorInput.value);

                if (startRgb) {
                    const startHsl = rgbToHsl(startRgb.r, startRgb.g, startRgb.b);
                    HUE_START = startHsl.h;
                }

                if (endRgb) {
                    const endHsl = rgbToHsl(endRgb.r, endRgb.g, endRgb.b);
                    HUE_END = endHsl.h;
                }

                if (bgRgb) {
                    BG_COLOR_R = bgRgb.r;
                    BG_COLOR_G = bgRgb.g;
                    BG_COLOR_B = bgRgb.b;
                }
            }

            // --- Export Handler ---
            /**
             * Generates self-contained HTML, CSS, and JS code for the current animation
             */
            function handleExportClick() {
                // Generate the CSS
                const cssCode = `/* Vector Animation Styles */
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #111827;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
}`;

                // Generate the JavaScript with the current vector field
                const jsCode = `// Vector Animation Script
// Current field: ${currentDescription}

const canvas = document.getElementById('vectorCanvas');
const ctx = canvas.getContext('2d');

// Configuration
const NUM_PARTICLES = ${NUM_PARTICLES};
const PARTICLE_SPEED = ${PARTICLE_SPEED};
const PARTICLE_SIZE = ${PARTICLE_SIZE};
const FIELD_SCALE = 8;
const FADE_OPACITY = 0.05;
const HUE_START = ${Math.round(HUE_START)};
const HUE_END = ${Math.round(HUE_END)};
const BG_COLOR_R = ${BG_COLOR_R};
const BG_COLOR_G = ${BG_COLOR_G};
const BG_COLOR_B = ${BG_COLOR_B};

let particles = [];
let canvasWidth = 0;
let canvasHeight = 0;

// Vector field function - this defines the animation behavior
const vectorFunction = new Function('x', 'y', 
    'with(Math) { return { x: (${currentVxString}), y: (${currentVyString}) }; }'
);

function getVectorAt(x, y) {
    try {
        return vectorFunction(x, y);
    } catch (e) {
        return { x: 0, y: 0 };
    }
}

class Particle {
    constructor() {
        this.reset();
    }
    
    reset() {
        this.x = Math.random() * canvasWidth;
        this.y = Math.random() * canvasHeight;
        this.vx = 0;
        this.vy = 0;
    }
    
    update() {
        const mathX = map(this.x, 0, canvasWidth, 0, FIELD_SCALE);
        const mathY = map(this.y, 0, canvasHeight, 0, FIELD_SCALE);
        const vector = getVectorAt(mathX, mathY);
        
        this.x += vector.x * PARTICLE_SPEED;
        this.y += vector.y * PARTICLE_SPEED;
        this.vx = vector.x;
        this.vy = vector.y;

        const magnitudeSq = (this.vx * this.vx) + (this.vy * this.vy);
        const randomRespawnChance = 0.001;

        if (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight || 
            magnitudeSq < 0.0001 || Math.random() < randomRespawnChance) {
            this.reset();
        }
    }
    
    draw() {
        const hue = map(this.x, 0, canvasWidth, HUE_START, HUE_END);
        ctx.fillStyle = 'hsl(' + hue + ', 80%, 60%)';
        ctx.fillRect(this.x, this.y, PARTICLE_SIZE, PARTICLE_SIZE);
    }
}

function map(value, inMin, inMax, outMin, outMax) {
    return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
}

function animate() {
    ctx.fillStyle = 'rgba(' + BG_COLOR_R + ', ' + BG_COLOR_G + ', ' + BG_COLOR_B + ', ' + FADE_OPACITY + ')';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    for (const particle of particles) {
        particle.update();
        particle.draw();
    }
    
    requestAnimationFrame(animate);
}

function setup() {
    const dpr = window.devicePixelRatio || 1;
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    
    canvasWidth = width;
    canvasHeight = height;
    
    particles = [];
    for (let i = 0; i < NUM_PARTICLES; i++) {
        particles.push(new Particle());
    }
    
    ctx.fillStyle = 'rgb(' + BG_COLOR_R + ', ' + BG_COLOR_G + ', ' + BG_COLOR_B + ')';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
}

// Initialize
setup();
window.addEventListener('resize', setup);
animate();`;

                // Generate the HTML
                const htmlCode = `<canvas id="vectorCanvas"></canvas>`;

                // Generate complete HTML file
                const completeHtml = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Field Animation - ${currentDescription}</title>
    <style>
${cssCode}
    </style>
</head>
<body>
    ${htmlCode}
    <` + `script>
${jsCode}
    </` + `script>
</body>
</html>`;

                // Populate the modal with the generated code
                exportHtmlCode.textContent = htmlCode;
                exportCssCode.textContent = cssCode;
                exportJsCode.textContent = jsCode;
                exportCompleteCode.textContent = completeHtml;

                // Show the export modal
                exportModal.classList.remove('hidden');
                exportStatus.textContent = '';
            }

            /**
             * Helper function to copy text to clipboard
             */
            async function copyToClipboard(text, buttonElement, successMessage) {
                try {
                    await navigator.clipboard.writeText(text);
                    exportStatus.textContent = successMessage;
                    setTimeout(() => {
                        exportStatus.textContent = '';
                    }, 3000);
                } catch (err) {
                    exportStatus.textContent = 'Failed to copy. Please copy manually.';
                    console.error('Failed to copy:', err);
                }
            }


            // --- Event Listeners ---
            generateButton.addEventListener('click', handleGenerateClick);
            explainButton.addEventListener('click', handleExplainClick);
            exportButton.addEventListener('click', handleExportClick);
            
            closeModalButton.addEventListener('click', () => {
                explanationModal.classList.add('hidden');
            });
            
            closeExportModalButton.addEventListener('click', () => {
                exportModal.classList.add('hidden');
            });
            
            // Copy button event listeners
            copyHtmlButton.addEventListener('click', () => {
                copyToClipboard(exportHtmlCode.textContent, copyHtmlButton, '‚úÖ HTML copied to clipboard!');
            });
            
            copyCssButton.addEventListener('click', () => {
                copyToClipboard(exportCssCode.textContent, copyCssButton, '‚úÖ CSS copied to clipboard!');
            });
            
            copyJsButton.addEventListener('click', () => {
                copyToClipboard(exportJsCode.textContent, copyJsButton, '‚úÖ JavaScript copied to clipboard!');
            });
            
            copyCompleteButton.addEventListener('click', () => {
                copyToClipboard(exportCompleteCode.textContent, copyCompleteButton, '‚úÖ Complete HTML copied to clipboard!');
            });
            
            // Preset dropdown event listener
            presetSelect.addEventListener('change', (e) => {
                const presetId = e.target.value;
                if (presetId) {
                    loadPreset(presetId);
                }
            });

            // Color input event listeners
            colorStartInput.addEventListener('input', (e) => {
                updateColors();
            });

            colorEndInput.addEventListener('input', (e) => {
                updateColors();
            });

            bgColorInput.addEventListener('input', (e) => {
                updateColors();
            });

            // Slider event listeners
            speedSlider.addEventListener('input', (e) => {
                PARTICLE_SPEED = parseFloat(e.target.value);
                speedValue.textContent = PARTICLE_SPEED.toFixed(1);
            });

            sizeSlider.addEventListener('input', (e) => {
                PARTICLE_SIZE = parseInt(e.target.value);
                sizeValue.textContent = PARTICLE_SIZE;
            });

            countSlider.addEventListener('input', (e) => {
                NUM_PARTICLES = parseInt(e.target.value);
                countValue.textContent = NUM_PARTICLES;
                setup(); // Reinitialize particles with new count
            });

            // Toggle API key input
            toggleApiKeyButton.addEventListener('click', () => {
                const isHidden = apiKeyContainer.classList.toggle('hidden');
                toggleApiKeyButton.textContent = isHidden ? '[API Key ‚ñº]' : '[API Key ‚ñ≤]';
            });

            // NEW: Listener for the collapsible description
            toggleDescriptionButton.addEventListener('click', () => {
                const isHidden = descriptionContent.classList.toggle('hidden');
                // Toggle the icon: Down arrow (‚ñº) when collapsed, Up arrow (‚ñ≤) when open
                toggleIcon.textContent = isHidden ? '‚ñº' : '‚ñ≤';
                // Render LaTeX when showing the description
                if (!isHidden && window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([descriptionContent]).catch((err) => console.log('MathJax typeset error:', err));
                }
            });

            // --- Canvas Logic (Original) ---
            
            /**
             * Gets the vector at a given mathematical coordinate.
             */
            function getVectorAt(x, y) {
                try {
                    if (vectorFunction) {
                        return vectorFunction(x, y);
                    }
                } catch (e) {
                    // Fallback for bad runtime function (e.g., division by zero)
                    return { x: 0, y: 0 };
                }
                return { x: 0, y: 0 }; // Default if function isn't set
            }

            class Particle {
                constructor() {
                    this.reset();
                }
                reset() {
                    this.x = Math.random() * canvasWidth;
                    this.y = Math.random() * canvasHeight;
                    this.vx = 0;
                    this.vy = 0;
                }
                update() {
                    const mathX = map(this.x, 0, canvasWidth, 0, FIELD_SCALE);
                    const mathY = map(this.y, 0, canvasHeight, 0, FIELD_SCALE);
                    const vector = getVectorAt(mathX, mathY);
                    this.x += vector.x * PARTICLE_SPEED;
                    this.y += vector.y * PARTICLE_SPEED;
                    this.vx = vector.x;
                    this.vy = vector.y;

                    // --- FIX: Check for stuck particles ---
                    // Calculate the magnitude (squared) of the vector
                    const magnitudeSq = (this.vx * this.vx) + (this.vy * this.vy);

                    // --- NEW: User's idea ---
                    // Add a small, random chance (e.g., 0.1%) for any particle to respawn
                    const randomRespawnChance = 0.001;

                    // Reset if off-screen OR if it's "stuck" (magnitude is very small)
                    // OR by random chance to keep the field populated
                    if (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight || magnitudeSq < 0.0001 || Math.random() < randomRespawnChance) {
                        this.reset();
                    }
                }
                draw() {
                    const hue = map(this.x, 0, canvasWidth, HUE_START, HUE_END);
                    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    ctx.fillRect(this.x, this.y, PARTICLE_SIZE, PARTICLE_SIZE);
                }
            }

            function map(value, inMin, inMax, outMin, outMax) {
                return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
            }

            function animate() {
                ctx.fillStyle = `rgba(${BG_COLOR_R}, ${BG_COLOR_G}, ${BG_COLOR_B}, ${FADE_OPACITY})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                for (const particle of particles) {
                    particle.update();
                    particle.draw();
                }
                requestAnimationFrame(animate);
            }

            function setup() {
                const container = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                canvasWidth = rect.width;
                canvasHeight = rect.height;
                particles = [];
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    particles.push(new Particle());
                }
                ctx.fillStyle = `rgb(${BG_COLOR_R}, ${BG_COLOR_G}, ${BG_COLOR_B})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }

            // --- Start ---
            
            // Set the initial vector function
            updateVectorFunction(currentVxString, currentVyString, currentDescription);
            
            // Set up the canvas and particles
            setup();

            // Add resize listener
            window.addEventListener('resize', setup);

            // Start the animation loop
            animate();
        });
    </script>
</body>
</html>
